# Busy Beaver
This is a repository of various java programs for the [Busiest Beaver project](https://wiki.bbchallenge.org/wiki/Main_Page).
All code in this repository is written without the assistance of AI.

Any files requested or generated by these programs will be located in the `data` directory.

To compile the code, run `javac -d ./bin *.java`.

## Programs
### Beaver
Beaver is a simple implementation of a Turing machine. It accepts the TM in [Tree Normal Form](https://wiki.bbchallenge.org/wiki/Tree_Normal_Form)

Command:
- `java Beaver <TM>`

### EnumerateSubtapes
EnumerateSubtapes is a program that exhaustively enumerates all subtapes of a fixed length that could /possibly/ be generated by the TM, ignoring its actual behavior.
EnumerateSubtapes is used to generate the [Subtape Saturation Heuristic](https://docs.google.com/spreadsheets/d/1j00LBxxp9W7uz1wZdMIvDCZ56eReuH0IGO9Z8-yybcQ/view?usp=sharing), which theoretically identifies Turing Machines that are susceptible to block analysis or longitudinal analysis.

In Google Sheets, the heuristic is calculated with the formula `=AVERAGE(FILTER(K3:BB3/(J3:BA3 * E$2^(K$2:BB$2-J$2:BA$2)) * LOG(K$2:BB$2), K3:BB3))` where row 3 contains the enumerated subtape counts and row 2 contains the length of the subtapes. (E2 contains the number of symbols used by the TM)
For clarity, the value for subtape length 3 is `Enum(3)/(Enum(2) * <TM Symbol Count>^(3 - 2)) * LOG(3)`.
- `Enum(2) * <TM Symbol Count>^(3 - 2))` is the maximum possible length 3 subtapes that could be generated given a known enumeration of the subtapes of length 2, so the first portion of the formula is the percentage of the possible length 3 subtapes that were actually generated.
- `LOG(3)` is used to give more weight to larger subtape lengths, which have more variability than shorter subtape lengths.

To generate the enumerations for the Subtape Saturation Heuristic, use the following command:
- `java EnumerateSubtapes <TM List File> <Output CSV Filename> 1000000`

Other commands for EnumerateSubtapes:
- `java EnumerateSubtapes [<logging level, 0-2>] <TM List File> <Length Parameters> [<Output CSV Filename> [<Max Subtapes To Enumerate>]]`

Running with the `<Output CSV Filename>` generates a CSV file to import the subtape lengths into a spreadsheet. Running without it will print the results to the console.
`<Max Subtapes To Enumerate>` prevents the program from enumerating greater subtape lengths after it runs on a length that enumerates that many subtapes. This helps with performance and prevents memory issues.

Length parameters can be:
- A single integer to run on a single subtape length
- A `start index` and `end index` to enumerate with a range of lengths in the first 45 primes
- A `minimum`, `maximum`, and `step` to enumerate with custom lengths `step`s apart 

### ESRecursive
ESRecursive enumerates fixed-length subtapes just like EnumerateSubtapes does, but it abstracts the tape away to improve performance. ESRecursive is used on a single TM at a time.

Command:
- `java ESRecursive <TM> <Length of initial subtape> <Length of recursive subtapes> <Number of times to recurse> [<logging level, 0-2>]`

For an initial subtape length n, a recursive length of r, and a recursion count of k, this program enumerates subtapes of size n, n * r, n * r^2, ..., n * r^k.
For example, you can enumerate size 40 subtapes with the values `10 2 2`, `5 2 3`, or even `40 0 0`.

### BBReverseSolver
BBReverseSolver is the first project developed for this repository. This program runs a TM backwards from its halt transition. It performs a depth-first search looking for the start state (state A with only zeros on the tape). Once it reaches the specific maximum depth, it records the path of states in a trie and backtracks to continue its search. Disabling trie generation can be preferable at large depths, as printing these tries can take several minutes.
Behavior on TMs with multiple halt transition is undefined.

Command:
- `java BBReverseSolver <TM> <Search depth> [<'false' to disable trie generation>]`

### SubtapeStepCounter
SubtapeStepCounter was a project to explore the maximum number of steps each size of TM can take in a fixed-size subtape. The program is parallelized to reduce the time taken to run on the datasets required.
The theoretical maximum steps taken in a size `n` subtape by a TM in the form `BB(s,k)` is `n * s * k^n`

The result was that for BB(2) and BB(2,3), the maximum number of steps for halting TMs increases linearly with subtape length.
For BB(3,2), the maximum steps for halting TMs increased at half the rate of the theoretical maximum.
After BB(4), the maximum steps for halting TMs increased on the same order as the theoretical maximum.

SubtapeStepCounter does not support command line arguments.
